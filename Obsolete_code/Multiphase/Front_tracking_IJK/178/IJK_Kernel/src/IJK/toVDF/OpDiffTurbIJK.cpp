/****************************************************************************
* Copyright (c) 2015 - 2016, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
/////////////////////////////////////////////////////////////////////////////
//
// File      : OpDiffTurbIJK.cpp
// Directory : $IJK_ROOT/src/IJK/OpVDF
//
/////////////////////////////////////////////////////////////////////////////
#include <OpDiffTurbIJK.h>
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file OpDiffTurbIJK.cpp.P
//
#include <IJK_Splitting.h>


/*
 * Options for CASE
 *
 *          Yes_Turb: the flux is turbulent_mu * (grad u + grad^T u)  -  2/3 * k  +  molecular_mu * grad u)'
 *          Yes_M_Grad: the flux is 'molecular_mu * grad u'
 *          Yes_M_Trans: the flux is 'molecular_mu * (grad u + grad^T u)'
 *          Yes_M_Div: the flux is 'molecular_mu * (grad u + grad^T u - 2/3 * div u * Id)'
 *          Yes_M_GradAnisotropic: the flux is 'molecular_mu^a * grad^a u' where (grad^a)_i = Delta_i (grad)_i
 *          Yes_M_TransAnisotropic: the flux is 'molecular_mu^a * (grad^a u + grad^a^T u)' where (grad^a)_i = Delta_i (grad)_i
 *          Yes_M_DivAnisotropic: the flux is 'molecular_mu^a * (grad^a u + grad^a^T u - 2/3 * div^a u * Id)' where (grad^a)_i = Delta_i (grad)_i
 *          Yes_M_GradTensorial: the flux is 'molecular_mu_tensor * grad u'
 *          Yes_M_TransTensorial: the flux is 'molecular_mu_tensor * (grad u + grad^T u)'
 *          Yes_M_DivTensorial: the flux is 'molecular_mu_tensor * (grad u + grad^T u - 2/3 * div u * Id)'
 *          Yes_M_GradTensorialAnisotropic: the flux is 'molecular_mu_tensor^a * grad^a u' where (grad^a)_i = Delta_i (grad)_i
 *          Yes_M_TransTensorialAnisotropic: the flux is 'molecular_mu_tensor^a * (grad^a u + grad^a^T u)' where (grad^a)_i = Delta_i (grad)_i
 *          Yes_M_DivTensorialAnisotropic: the flux is 'molecular_mu_tensor^a * (grad^a u + grad^a^T u - 2/3 * div^a u * Id)' where (grad^a)_i = Delta_i (grad)_i
 *          Yes_M_Struct: the flux is 'structural_model'
 */

OpDiffTurbIJK_double::OpDiffTurbIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

  turbulent_nu_ = 0;
  turbulent_k_energy_ = 0;
}

void OpDiffTurbIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffTurbIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                   const IJK_Field_double& molecular_nu,
                                   const IJK_Field_double& turbulent_nu,
                                   const IJK_Field_double& turbulent_k_energy,
                                   IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  turbulent_nu_ = &turbulent_nu;
  turbulent_k_energy_ = &turbulent_k_energy;
  compute_add(dvx, dvy, dvz);
}
void OpDiffTurbIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                    const IJK_Field_double& molecular_nu,
                                    const IJK_Field_double& turbulent_nu,
                                    const IJK_Field_double& turbulent_k_energy,
                                    IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  turbulent_nu_ = &turbulent_nu;
  turbulent_k_energy_ = &turbulent_k_energy;
  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            Simd_double t_nu, t_nu_dummy;
            turbulent_nu.get_left_center_x(i, t_nu, t_nu_dummy);
            Simd_double minus_reyn = t_nu * tau * (2.);
            // Shall we include "k" or not ? If we do, it is equivalent to adding
            //  grad(k) to the rhs of Navier Stokes, il we be "eaten" by the pressure
            //  solver.
            Simd_double k, k_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            turbulent_k_energy.get_left_center_x(i, k, k_dummy);
            minus_reyn += (-0.66666666666666666) * k;
            // Check that diagonal terms of the Reynolds tensor are positive
            //  (exactly copied from Eval_Dift_VDF_var_Face::flux_fa7_elem)
            minus_reyn = SimdMin(minus_reyn, 0.);
            flux = (minus_reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        turbulent_k_energy.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
            turbulent_nu.get_left_center_xy(i, t_nu1, t_nu2, t_nu3, t_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            Simd_double t_nu = (t_nu1 + t_nu2 + t_nu3 + t_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            Simd_double reyn = (tau + tau_tr) * t_nu;
            flux = (reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
            turbulent_nu.get_left_center_xz(i, t_nu1, t_nu2, t_nu3, t_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            Simd_double t_nu = (t_nu1 + t_nu2 + t_nu3 + t_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            Simd_double reyn = (tau + tau_tr) * t_nu;
            flux = (reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
            turbulent_nu.get_left_center_yx(i, t_nu1, t_nu2, t_nu3, t_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            Simd_double t_nu = (t_nu1 + t_nu2 + t_nu3 + t_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            Simd_double reyn = (tau + tau_tr) * t_nu;
            flux = (reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            Simd_double t_nu, t_nu_dummy;
            turbulent_nu.get_left_center_y(i, t_nu, t_nu_dummy);
            Simd_double minus_reyn = t_nu * tau * (2.);
            // Shall we include "k" or not ? If we do, it is equivalent to adding
            //  grad(k) to the rhs of Navier Stokes, il we be "eaten" by the pressure
            //  solver.
            Simd_double k, k_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            turbulent_k_energy.get_left_center_y(i, k, k_dummy);
            minus_reyn += (-0.66666666666666666) * k;
            // Check that diagonal terms of the Reynolds tensor are positive
            //  (exactly copied from Eval_Dift_VDF_var_Face::flux_fa7_elem)
            minus_reyn = SimdMin(minus_reyn, 0.);
            flux = (minus_reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        turbulent_k_energy.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
            turbulent_nu.get_left_center_yz(i, t_nu1, t_nu2, t_nu3, t_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            Simd_double t_nu = (t_nu1 + t_nu2 + t_nu3 + t_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            Simd_double reyn = (tau + tau_tr) * t_nu;
            flux = (reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
          // Turbulent kinetic energy from turbulence model
          //ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
                          turbulent_nu.get_left_center_zx(i, t_nu1, t_nu2, t_nu3, t_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          Simd_double t_nu = (t_nu3 + t_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * (t_nu + m_nu);

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      turbulent_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTurbIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
          // Turbulent kinetic energy from turbulence model
          //ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
                          turbulent_nu.get_left_center_zx(i, t_nu1, t_nu2, t_nu3, t_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          Simd_double t_nu = (t_nu1 + t_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * (t_nu + m_nu);

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      turbulent_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTurbIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
            turbulent_nu.get_left_center_zx(i, t_nu1, t_nu2, t_nu3, t_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            Simd_double t_nu = (t_nu1 + t_nu2 + t_nu3 + t_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            Simd_double reyn = (tau + tau_tr) * t_nu;
            flux = (reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
          // Turbulent kinetic energy from turbulence model
          //ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
                          turbulent_nu.get_left_center_zy(i, t_nu1, t_nu2, t_nu3, t_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          Simd_double t_nu = (t_nu3 + t_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * (t_nu + m_nu);

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      turbulent_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTurbIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
          // Turbulent kinetic energy from turbulence model
          //ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
                          turbulent_nu.get_left_center_zy(i, t_nu1, t_nu2, t_nu3, t_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          Simd_double t_nu = (t_nu1 + t_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * (t_nu + m_nu);

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      turbulent_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTurbIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            Simd_double t_nu1, t_nu2, t_nu3, t_nu4;
            turbulent_nu.get_left_center_zy(i, t_nu1, t_nu2, t_nu3, t_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            Simd_double t_nu = (t_nu1 + t_nu2 + t_nu3 + t_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            Simd_double reyn = (tau + tau_tr) * t_nu;
            flux = (reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTurbIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr turbulent_nu(*turbulent_nu_, 0, 0, k_layer);
  // Turbulent kinetic energy from turbulence model
  ConstIJK_double_ptr turbulent_k_energy(*turbulent_k_energy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            Simd_double t_nu, t_nu_dummy;
            turbulent_nu.get_left_center_z(i, t_nu, t_nu_dummy);
            Simd_double minus_reyn = t_nu * tau * (2.);
            // Shall we include "k" or not ? If we do, it is equivalent to adding
            //  grad(k) to the rhs of Navier Stokes, il we be "eaten" by the pressure
            //  solver.
            Simd_double k, k_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            turbulent_k_energy.get_left_center_z(i, k, k_dummy);
            minus_reyn += (-0.66666666666666666) * k;
            // Check that diagonal terms of the Reynolds tensor are positive
            //  (exactly copied from Eval_Dift_VDF_var_Face::flux_fa7_elem)
            minus_reyn = SimdMin(minus_reyn, 0.);
            flux = (minus_reyn + m_nu * tau) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        turbulent_nu.next_j();
        turbulent_k_energy.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffIJK_double::OpDiffIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

}

void OpDiffIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                               const IJK_Field_double& molecular_nu,
                               IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_add(dvx, dvy, dvz);
}
void OpDiffIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                const IJK_Field_double& molecular_nu,
                                IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeIJK_double::OpDiffStdWithLaminarTransposeIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

}

void OpDiffStdWithLaminarTransposeIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                      const IJK_Field_double& molecular_nu,
                                                      IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                       const IJK_Field_double& molecular_nu,
                                                       IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::OpDiffStdWithLaminarTransposeAndDivergenceIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

  divergence_ = 0;
}

void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                   const IJK_Field_double& molecular_nu,
                                                                   const IJK_Field_double& divergence,
                                                                   IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  divergence_ = &divergence;
  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                    const IJK_Field_double& molecular_nu,
                                                                    const IJK_Field_double& divergence,
                                                                    IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  divergence_ = &divergence;
  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_x(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_y(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * inv_distance_z; //inv_distance_z : distance to wall already contains 1/2
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * inv_distance_z; //distance to wall
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_z(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffAnisotropicIJK_double::OpDiffAnisotropicIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

}

void OpDiffAnisotropicIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffAnisotropicIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                          const IJK_Field_double& molecular_nu,
                                          IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_add(dvx, dvy, dvz);
}
void OpDiffAnisotropicIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                           const IJK_Field_double& molecular_nu,
                                           IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * 2.;
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * 2.;
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * 2.;
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * 2.;
                          flux = tau * surface * m_nu;

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffAnisotropicIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeAnisotropicIJK_double::OpDiffStdWithLaminarTransposeAnisotropicIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

}

void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                 const IJK_Field_double& molecular_nu,
                                                                 IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                  const IJK_Field_double& molecular_nu,
                                                                  IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAnisotropicIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_ = 0;

  divergence_ = 0;
}

void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                              const IJK_Field_double& molecular_nu,
                                                                              const IJK_Field_double& divergence,
                                                                              IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  divergence_ = &divergence;
  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                               const IJK_Field_double& molecular_nu,
                                                                               const IJK_Field_double& divergence,
                                                                               IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_ = &molecular_nu;

  divergence_ = &divergence;
  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1);
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_x(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1);
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_y(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu3 + m_nu4) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // bottom wall (z=0), v3 is left, hence in the wall)
                          Simd_double tau = (v4 - 0.) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          Simd_double m_nu = (m_nu1 + m_nu2) * 0.5;
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          // top wall (z=zmax), v4 is center, hence in the wall)
                          Simd_double tau = (0. - v3) * 2.;
                          flux = tau * surface * m_nu; // because tau_tr=dw/dx=0 at the wall.

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceAnisotropicIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1);
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_z(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffTensorialZeroatwallIJK_double::OpDiffTensorialZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_tensor_xx_ = 0;
  molecular_nu_tensor_xy_ = 0;
  molecular_nu_tensor_xz_ = 0;
  molecular_nu_tensor_yx_ = 0;
  molecular_nu_tensor_yy_ = 0;
  molecular_nu_tensor_yz_ = 0;
  molecular_nu_tensor_zx_ = 0;
  molecular_nu_tensor_zy_ = 0;
  molecular_nu_tensor_zz_ = 0;

}

void OpDiffTensorialZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffTensorialZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                  const IJK_Field_double& molecular_nu_tensor_xx,
                                                  const IJK_Field_double& molecular_nu_tensor_xy,
                                                  const IJK_Field_double& molecular_nu_tensor_xz,
                                                  const IJK_Field_double& molecular_nu_tensor_yx,
                                                  const IJK_Field_double& molecular_nu_tensor_yy,
                                                  const IJK_Field_double& molecular_nu_tensor_yz,
                                                  const IJK_Field_double& molecular_nu_tensor_zx,
                                                  const IJK_Field_double& molecular_nu_tensor_zy,
                                                  const IJK_Field_double& molecular_nu_tensor_zz,
                                                  IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_add(dvx, dvy, dvz);
}
void OpDiffTensorialZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                   const IJK_Field_double& molecular_nu_tensor_xx,
                                                   const IJK_Field_double& molecular_nu_tensor_xy,
                                                   const IJK_Field_double& molecular_nu_tensor_xz,
                                                   const IJK_Field_double& molecular_nu_tensor_yx,
                                                   const IJK_Field_double& molecular_nu_tensor_yy,
                                                   const IJK_Field_double& molecular_nu_tensor_yz,
                                                   const IJK_Field_double& molecular_nu_tensor_zx,
                                                   const IJK_Field_double& molecular_nu_tensor_zy,
                                                   const IJK_Field_double& molecular_nu_tensor_zz,
                                                   IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_tensor_xx_ = 0;
  molecular_nu_tensor_xy_ = 0;
  molecular_nu_tensor_xz_ = 0;
  molecular_nu_tensor_yx_ = 0;
  molecular_nu_tensor_yy_ = 0;
  molecular_nu_tensor_yz_ = 0;
  molecular_nu_tensor_zx_ = 0;
  molecular_nu_tensor_zy_ = 0;
  molecular_nu_tensor_zz_ = 0;

}

void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                         const IJK_Field_double& molecular_nu_tensor_xx,
                                                                         const IJK_Field_double& molecular_nu_tensor_xy,
                                                                         const IJK_Field_double& molecular_nu_tensor_xz,
                                                                         const IJK_Field_double& molecular_nu_tensor_yx,
                                                                         const IJK_Field_double& molecular_nu_tensor_yy,
                                                                         const IJK_Field_double& molecular_nu_tensor_yz,
                                                                         const IJK_Field_double& molecular_nu_tensor_zx,
                                                                         const IJK_Field_double& molecular_nu_tensor_zy,
                                                                         const IJK_Field_double& molecular_nu_tensor_zz,
                                                                         IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                          const IJK_Field_double& molecular_nu_tensor_xx,
                                                                          const IJK_Field_double& molecular_nu_tensor_xy,
                                                                          const IJK_Field_double& molecular_nu_tensor_xz,
                                                                          const IJK_Field_double& molecular_nu_tensor_yx,
                                                                          const IJK_Field_double& molecular_nu_tensor_yy,
                                                                          const IJK_Field_double& molecular_nu_tensor_yz,
                                                                          const IJK_Field_double& molecular_nu_tensor_zx,
                                                                          const IJK_Field_double& molecular_nu_tensor_zy,
                                                                          const IJK_Field_double& molecular_nu_tensor_zz,
                                                                          IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_tensor_xx_ = 0;
  molecular_nu_tensor_xy_ = 0;
  molecular_nu_tensor_xz_ = 0;
  molecular_nu_tensor_yx_ = 0;
  molecular_nu_tensor_yy_ = 0;
  molecular_nu_tensor_yz_ = 0;
  molecular_nu_tensor_zx_ = 0;
  molecular_nu_tensor_zy_ = 0;
  molecular_nu_tensor_zz_ = 0;

  divergence_ = 0;
}

void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                                      const IJK_Field_double& molecular_nu_tensor_xx,
                                                                                      const IJK_Field_double& molecular_nu_tensor_xy,
                                                                                      const IJK_Field_double& molecular_nu_tensor_xz,
                                                                                      const IJK_Field_double& molecular_nu_tensor_yx,
                                                                                      const IJK_Field_double& molecular_nu_tensor_yy,
                                                                                      const IJK_Field_double& molecular_nu_tensor_yz,
                                                                                      const IJK_Field_double& molecular_nu_tensor_zx,
                                                                                      const IJK_Field_double& molecular_nu_tensor_zy,
                                                                                      const IJK_Field_double& molecular_nu_tensor_zz,
                                                                                      const IJK_Field_double& divergence,
                                                                                      IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  divergence_ = &divergence;
  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                                       const IJK_Field_double& molecular_nu_tensor_xx,
                                                                                       const IJK_Field_double& molecular_nu_tensor_xy,
                                                                                       const IJK_Field_double& molecular_nu_tensor_xz,
                                                                                       const IJK_Field_double& molecular_nu_tensor_yx,
                                                                                       const IJK_Field_double& molecular_nu_tensor_yy,
                                                                                       const IJK_Field_double& molecular_nu_tensor_yz,
                                                                                       const IJK_Field_double& molecular_nu_tensor_zx,
                                                                                       const IJK_Field_double& molecular_nu_tensor_zy,
                                                                                       const IJK_Field_double& molecular_nu_tensor_zz,
                                                                                       const IJK_Field_double& divergence,
                                                                                       IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  divergence_ = &divergence;
  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xx_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_x;
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_x(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yx_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zx_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_x;
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xy_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yy_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_y;
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_y(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zy_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_y;
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_z;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_x = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_x;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_y = channel_data_.inv_distance_for_gradient(k_layer, idir, icompo);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3) * inv_distance_z;
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1) * inv_distance_y;
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  const double inv_distance_z = channel_data_.inv_distance_for_gradient(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zz_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1) * inv_distance_z;
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_z(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffTensorialAnisotropicZeroatwallIJK_double::OpDiffTensorialAnisotropicZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_tensor_xx_ = 0;
  molecular_nu_tensor_xy_ = 0;
  molecular_nu_tensor_xz_ = 0;
  molecular_nu_tensor_yx_ = 0;
  molecular_nu_tensor_yy_ = 0;
  molecular_nu_tensor_yz_ = 0;
  molecular_nu_tensor_zx_ = 0;
  molecular_nu_tensor_zy_ = 0;
  molecular_nu_tensor_zz_ = 0;

}

void OpDiffTensorialAnisotropicZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffTensorialAnisotropicZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                             const IJK_Field_double& molecular_nu_tensor_xx,
                                                             const IJK_Field_double& molecular_nu_tensor_xy,
                                                             const IJK_Field_double& molecular_nu_tensor_xz,
                                                             const IJK_Field_double& molecular_nu_tensor_yx,
                                                             const IJK_Field_double& molecular_nu_tensor_yy,
                                                             const IJK_Field_double& molecular_nu_tensor_yz,
                                                             const IJK_Field_double& molecular_nu_tensor_zx,
                                                             const IJK_Field_double& molecular_nu_tensor_zy,
                                                             const IJK_Field_double& molecular_nu_tensor_zz,
                                                             IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_add(dvx, dvy, dvz);
}
void OpDiffTensorialAnisotropicZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                              const IJK_Field_double& molecular_nu_tensor_xx,
                                                              const IJK_Field_double& molecular_nu_tensor_xy,
                                                              const IJK_Field_double& molecular_nu_tensor_xz,
                                                              const IJK_Field_double& molecular_nu_tensor_yx,
                                                              const IJK_Field_double& molecular_nu_tensor_yy,
                                                              const IJK_Field_double& molecular_nu_tensor_yz,
                                                              const IJK_Field_double& molecular_nu_tensor_zx,
                                                              const IJK_Field_double& molecular_nu_tensor_zy,
                                                              const IJK_Field_double& molecular_nu_tensor_zz,
                                                              IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            flux = m_nu * tau * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * tau * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_tensor_xx_ = 0;
  molecular_nu_tensor_xy_ = 0;
  molecular_nu_tensor_xz_ = 0;
  molecular_nu_tensor_yx_ = 0;
  molecular_nu_tensor_yy_ = 0;
  molecular_nu_tensor_yz_ = 0;
  molecular_nu_tensor_zx_ = 0;
  molecular_nu_tensor_zy_ = 0;
  molecular_nu_tensor_zz_ = 0;

}

void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                                    const IJK_Field_double& molecular_nu_tensor_xx,
                                                                                    const IJK_Field_double& molecular_nu_tensor_xy,
                                                                                    const IJK_Field_double& molecular_nu_tensor_xz,
                                                                                    const IJK_Field_double& molecular_nu_tensor_yx,
                                                                                    const IJK_Field_double& molecular_nu_tensor_yy,
                                                                                    const IJK_Field_double& molecular_nu_tensor_yz,
                                                                                    const IJK_Field_double& molecular_nu_tensor_zx,
                                                                                    const IJK_Field_double& molecular_nu_tensor_zy,
                                                                                    const IJK_Field_double& molecular_nu_tensor_zz,
                                                                                    IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                                     const IJK_Field_double& molecular_nu_tensor_xx,
                                                                                     const IJK_Field_double& molecular_nu_tensor_xy,
                                                                                     const IJK_Field_double& molecular_nu_tensor_xz,
                                                                                     const IJK_Field_double& molecular_nu_tensor_yx,
                                                                                     const IJK_Field_double& molecular_nu_tensor_yy,
                                                                                     const IJK_Field_double& molecular_nu_tensor_yz,
                                                                                     const IJK_Field_double& molecular_nu_tensor_zx,
                                                                                     const IJK_Field_double& molecular_nu_tensor_zy,
                                                                                     const IJK_Field_double& molecular_nu_tensor_zz,
                                                                                     IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1);
            flux = m_nu * 2. * tau * surface; // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  molecular_nu_tensor_xx_ = 0;
  molecular_nu_tensor_xy_ = 0;
  molecular_nu_tensor_xz_ = 0;
  molecular_nu_tensor_yx_ = 0;
  molecular_nu_tensor_yy_ = 0;
  molecular_nu_tensor_yz_ = 0;
  molecular_nu_tensor_zx_ = 0;
  molecular_nu_tensor_zy_ = 0;
  molecular_nu_tensor_zz_ = 0;

  divergence_ = 0;
}

void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_xx,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_xy,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_xz,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_yx,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_yy,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_yz,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_zx,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_zy,
                                                                                                 const IJK_Field_double& molecular_nu_tensor_zz,
                                                                                                 const IJK_Field_double& divergence,
                                                                                                 IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  divergence_ = &divergence;
  compute_add(dvx, dvy, dvz);
}
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_xx,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_xy,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_xz,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_yx,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_yy,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_yz,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_zx,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_zy,
                                                                                                  const IJK_Field_double& molecular_nu_tensor_zz,
                                                                                                  const IJK_Field_double& divergence,
                                                                                                  IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;

  molecular_nu_tensor_xx_ = &molecular_nu_tensor_xx;
  molecular_nu_tensor_xy_ = &molecular_nu_tensor_xy;
  molecular_nu_tensor_xz_ = &molecular_nu_tensor_xz;
  molecular_nu_tensor_yx_ = &molecular_nu_tensor_yx;
  molecular_nu_tensor_yy_ = &molecular_nu_tensor_yy;
  molecular_nu_tensor_yz_ = &molecular_nu_tensor_yz;
  molecular_nu_tensor_zx_ = &molecular_nu_tensor_zx;
  molecular_nu_tensor_zy_ = &molecular_nu_tensor_zy;
  molecular_nu_tensor_zz_ = &molecular_nu_tensor_zz;

  divergence_ = &divergence;
  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xx_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_x(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vx_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau = (v2 - v1);
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_x(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yx_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zx_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_xz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component x
            Simd_double v1, v2;
            vx_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xy_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yy_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_y(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vy_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau = (v2 - v1);
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_y(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zy_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_yz(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction z of component y
            Simd_double v1, v2;
            vy_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_xz_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zx(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction x of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_x(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
                          molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // do nothing
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      molecular_nu.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_yz_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double m_nu1, m_nu2, m_nu3, m_nu4;
            molecular_nu.get_left_center_zy(i, m_nu1, m_nu2, m_nu3, m_nu4);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            Simd_double m_nu = (m_nu1 + m_nu2 + m_nu3 + m_nu4) * 0.25;
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            Simd_double tau = (v4 - v3);
            // gradient in direction y of component z
            Simd_double v1, v2;
            vz_ptr.get_left_center_y(i, v1, v2);
            Simd_double tau_tr = (v2 - v1);
            flux = m_nu * (tau + tau_tr) * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        molecular_nu.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStdWithLaminarTransposeAndDivergenceTensorialAnisotropicZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr molecular_nu(*molecular_nu_tensor_zz_, 0, 0, k_layer);
  ConstIJK_double_ptr div_ptr(*divergence_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // recoding of Eval_Dift_VDF_var_Face::flux_fa7_elem
            Simd_double m_nu, m_nu_dummy;
            // flux is between left face and center face, hence, it is centered on the "left" cell
            molecular_nu.get_left_center_z(i, m_nu, m_nu_dummy);
            Simd_double v1, v2;
            vz_ptr.get_left_center_z(i, v1, v2);
            Simd_double tau = (v2 - v1);
            Simd_double v5, v6_dummy;
            div_ptr.get_left_center_z(i, v5, v6_dummy);
            flux = m_nu * surface * (2. * tau - 0.66666666666666666 * v5); // The factor 2. is because tau_tr = tau
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        molecular_nu.next_j();
        div_ptr.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

OpDiffStructuralOnlyZeroatwallIJK_double::OpDiffStructuralOnlyZeroatwallIJK_double()
{
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;

  structural_model_xx_ = 0;
  structural_model_xy_ = 0;
  structural_model_xz_ = 0;
  structural_model_yx_ = 0;
  structural_model_yy_ = 0;
  structural_model_yz_ = 0;
  structural_model_zx_ = 0;
  structural_model_zy_ = 0;
  structural_model_zz_ = 0;
}

void OpDiffStructuralOnlyZeroatwallIJK_double::initialize(const IJK_Splitting& splitting, const Boundary_Conditions& bc)
{
  perio_k_= splitting.get_grid_geometry().get_periodic_flag(DIRECTION_K);
  channel_data_.initialize(splitting);
  ref_bc_ = bc;
}

void OpDiffStructuralOnlyZeroatwallIJK_double::ajouter(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                       const IJK_Field_double& structural_model_xx,
                                                       const IJK_Field_double& structural_model_xy,
                                                       const IJK_Field_double& structural_model_xz,
                                                       const IJK_Field_double& structural_model_yx,
                                                       const IJK_Field_double& structural_model_yy,
                                                       const IJK_Field_double& structural_model_yz,
                                                       const IJK_Field_double& structural_model_zx,
                                                       const IJK_Field_double& structural_model_zy,
                                                       const IJK_Field_double& structural_model_zz,
                                                       IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;


  structural_model_xx_ = &structural_model_xx;
  structural_model_xy_ = &structural_model_xy;
  structural_model_xz_ = &structural_model_xz;
  structural_model_yx_ = &structural_model_yx;
  structural_model_yy_ = &structural_model_yy;
  structural_model_yz_ = &structural_model_yz;
  structural_model_zx_ = &structural_model_zx;
  structural_model_zy_ = &structural_model_zy;
  structural_model_zz_ = &structural_model_zz;
  compute_add(dvx, dvy, dvz);
}
void OpDiffStructuralOnlyZeroatwallIJK_double::calculer(const IJK_Field_double& vx, const IJK_Field_double& vy, const IJK_Field_double& vz,
                                                        const IJK_Field_double& structural_model_xx,
                                                        const IJK_Field_double& structural_model_xy,
                                                        const IJK_Field_double& structural_model_xz,
                                                        const IJK_Field_double& structural_model_yx,
                                                        const IJK_Field_double& structural_model_yy,
                                                        const IJK_Field_double& structural_model_yz,
                                                        const IJK_Field_double& structural_model_zx,
                                                        const IJK_Field_double& structural_model_zy,
                                                        const IJK_Field_double& structural_model_zz,
                                                        IJK_Field_double& dvx, IJK_Field_double& dvy, IJK_Field_double& dvz)
{
  vx_ = &vx;
  vy_ = &vy;
  vz_ = &vz;


  structural_model_xx_ = &structural_model_xx;
  structural_model_xy_ = &structural_model_xy;
  structural_model_xz_ = &structural_model_xz;
  structural_model_yx_ = &structural_model_yx;
  structural_model_yy_ = &structural_model_yy;
  structural_model_yz_ = &structural_model_yz;
  structural_model_zx_ = &structural_model_zx;
  structural_model_zy_ = &structural_model_zy;
  structural_model_zz_ = &structural_model_zz;
  compute_set(dvx, dvy, dvz);
}

// Description: compute fluxes in direction x for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_x_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vx_->ni() + 1;
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction x for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_xx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_x(i, s_mo, s_mo_dummy);
            flux = s_mo * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_x_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vy_->ni() + 1;
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction x for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_xy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_x(i, s_mo_dummy, s_mo);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            // gradient in direction x of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_x(i, v3, v4);
            flux = s_mo * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vx_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction x for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_x_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  const int idir = 0;
  const int nx = vz_->ni() + 1;
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction x for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_xz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_x(i, s_mo_dummy, s_mo);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            // gradient in direction x of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_x(i, v3, v4);
            flux = s_mo * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vx_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_y_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vx_->ni();
  const int ny = vx_->nj() + 1;
  const int icompo = 0;

  // Result (fluxes in direction y for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_yx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_y(i, s_mo_dummy, s_mo);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            // gradient in direction y of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_y(i, v3, v4);
            flux = s_mo * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vy_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_y_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vy_->ni();
  const int ny = vy_->nj() + 1;
  const int icompo = 1;
  // Result (fluxes in direction y for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_yy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_y(i, s_mo, s_mo_dummy);
            flux = s_mo * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction y for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_y_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  const int idir = 1;
  const int nx = vz_->ni();
  const int ny = vz_->nj() + 1;
  const int icompo = 2;
  // Result (fluxes in direction y for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_yz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_y(i, s_mo_dummy, s_mo);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            // gradient in direction y of component z
            Simd_double v3, v4;
            vz_ptr.get_left_center_y(i, v3, v4);
            flux = s_mo * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        vy_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component x
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_z_vx(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vx_ptr(*vx_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vx_->ni();
  const int ny = vx_->nj();
  const int icompo = 0;

  // Result (fluxes in direction z for component x of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr structural_model(*structural_model_xz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double s_mo, s_mo_dummy;
                          structural_model.get_left_center_z(i, s_mo_dummy, s_mo);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      structural_model.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStructuralOnlyZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr structural_model(*structural_model_zx_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double s_mo, s_mo_dummy;
                          structural_model.get_left_center_z(i, s_mo_dummy, s_mo);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // gradient in direction z of component x
                          Simd_double v3, v4;
                          vx_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vx_ptr.next_j();
                      vz_ptr.next_j();
                      structural_model.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStructuralOnlyZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_zx_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_z(i, s_mo_dummy, s_mo);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            // gradient in direction z of component x
            Simd_double v3, v4;
            vx_ptr.get_left_center_z(i, v3, v4);
            flux = s_mo * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vx_ptr.next_j();
        vz_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component y
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_z_vy(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vy_ptr(*vy_, 0, 0, k_layer);
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vy_->ni();
  const int ny = vy_->nj();
  const int icompo = 1;
  // Result (fluxes in direction z for component y of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      // For this direction and this component, we possibly have a wall boundary condition to treat:
      if (global_k_layer == first_global_k_layer-1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr structural_model(*structural_model_yz_, 0, 0, k_layer);
          // We are at bottom wall: z=0
          switch(ref_bc_.valeur().get_bctype_k_min())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double s_mo, s_mo_dummy;
                          structural_model.get_left_center_z(i, s_mo_dummy, s_mo);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // bottom wall (z=0)
                          // nu1 and nu2 are "left" in direction z, hence in the wall:
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      structural_model.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStructuralOnlyZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer == last_global_k_layer + 1)
        {
          // Variable diffusion coefficients: molecular and turbulent, at elements
          ConstIJK_double_ptr structural_model(*structural_model_zy_, 0, 0, k_layer);
          // We are at top wall: z=zmax
          switch(ref_bc_.valeur().get_bctype_k_max())
            {
            case Boundary_Conditions::Paroi:
              {

                {
                  const int imax = nx;
                  const int jmax = ny;
                  const int vsize = Simd_double::size();
                  for (int j = 0; ; j++)
                    {
                      for (int i = 0; i < imax; i += vsize)
                        {
                          Simd_double flux = 0.;
                          // Interpolate diffusion coefficient from values at elements:
                          Simd_double s_mo, s_mo_dummy;
                          structural_model.get_left_center_z(i, s_mo_dummy, s_mo);
                          // recoding of Eval_Dift_VDF_var_Face::flux_arete_paroi
                          // top wall (z=zmax)
                          // nu3 and nu4 are "center" in direction z, hence in the wall:
                          // gradient in direction z of component y
                          Simd_double v3, v4;
                          vy_ptr.get_left_center_z(i, v3, v4);
                          if (perio_k_)
                            {
                              flux = 0.;
                            }

                          resu_ptr.put_val(i, flux);
                        }
                      // do not execute end_iloop at last iteration (because of assert on valid j+1)
                      if (j+1==jmax)
                        break;
                      // instructions to perform to jump to next row
                      vy_ptr.next_j();
                      vz_ptr.next_j();
                      structural_model.next_j();
                      resu_ptr.next_j();
                    }
                }
                break;
              }
            case Boundary_Conditions::Symetrie:
              {
                // Symetry boundary condition: momentum flux is zero
                putzero(resu);
                break;
              }
            default:
              Cerr << "OpDiffStructuralOnlyZeroatwallIJK_double: wrong boundary condition." << finl;
              Process::exit();
            }
          return;
        }
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_zy_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            // Interpolate diffusion coefficient from values at elements:
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_z(i, s_mo_dummy, s_mo);
            // recoding of Eval_Dift_VDF_var_Face::flux_arete_interne
            // gradient in direction z of component y
            Simd_double v3, v4;
            vy_ptr.get_left_center_z(i, v3, v4);
            flux = s_mo * surface;

            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vy_ptr.next_j();
        vz_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

// Description: compute fluxes in direction z for velocity component z
//  for the layer of fluxes k_layer
// Diffusion
void OpDiffStructuralOnlyZeroatwallIJK_double::compute_flux_z_vz(IJK_Field_local_double& resu, const int k_layer)
{
  // Velocity field
  ConstIJK_double_ptr vz_ptr(*vz_, 0, 0, k_layer);
  const int idir = 2;
  const int nx = vz_->ni();
  const int ny = vz_->nj();
  const int icompo = 2;
  // Result (fluxes in direction z for component z of the convected field)
  IJK_double_ptr resu_ptr(resu, 0, 0, 0);


  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = channel_data_.first_global_k_layer_flux(icompo, idir);
  const int last_global_k_layer = channel_data_.last_global_k_layer_flux(icompo, idir);

  const double surface = - channel_data_.get_surface(k_layer, icompo, idir);
  if(!perio_k_)
    {
      if (global_k_layer < first_global_k_layer || global_k_layer > last_global_k_layer)
        {
          // We are inside the wall
          putzero(resu);
          return;
        }
      // Variable diffusion coefficients: molecular and turbulent, at elements
    }
  ConstIJK_double_ptr structural_model(*structural_model_zz_, 0, 0, k_layer);

  {
    const int imax = nx;
    const int jmax = ny;
    const int vsize = Simd_double::size();
    for (int j = 0; ; j++)
      {
        for (int i = 0; i < imax; i += vsize)
          {
            Simd_double flux = 0.;
            Simd_double s_mo, s_mo_dummy;
            structural_model.get_left_center_z(i, s_mo, s_mo_dummy);
            flux = s_mo * surface;
            resu_ptr.put_val(i, flux);
          }
        // do not execute end_iloop at last iteration (because of assert on valid j+1)
        if (j+1==jmax)
          break;
        // instructions to perform to jump to next row
        vz_ptr.next_j();
        structural_model.next_j();
        resu_ptr.next_j();
      }
  }

  // flops_ += nx * ny * 6;
}

