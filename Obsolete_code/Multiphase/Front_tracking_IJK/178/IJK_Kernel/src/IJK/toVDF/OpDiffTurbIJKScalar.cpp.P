/****************************************************************************
* Copyright (c) 2015 - 2016, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
/////////////////////////////////////////////////////////////////////////////
//
// File      : OpDiffTurbIJKScalar.cpp
// Directory : $IJK_ROOT/src/IJK/OpVDF
//
/////////////////////////////////////////////////////////////////////////////
#include <OpDiffTurbIJKScalar.h>

#Pinclude(IJ_LOOP_P)

#Pmacro DEFMACRO(ST)
void copy_boundary_condition(const IJK_Field_local_ST & boundary_flux, IJK_Field_local_ST & resu)
{
  assert(resu.ni() >= boundary_flux.ni());
  assert(resu.nj() >= boundary_flux.nj());
  // resu is the temporary array where all fluxes are stored before computing divergence,
  // they might have more place than ni and nj because there 1 more flux value dans velocity values
  // to compute divergence
  const int ni = boundary_flux.ni();
  const int nj = boundary_flux.nj();
  for (int j = 0; j < nj; j++)
    for (int i = 0; i < ni; i++)
      resu(i,j,0) = boundary_flux(i,j,0);
}
#Pendmacro(DEFMACRO)
#Pusemacro(DEFMACRO)(double)

#Pmacro DEFMACRO(ST,CASE,_OP_NAME_)

_OP_NAME__ST::_OP_NAME__ST()
{
  input_field_ = 0;
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
  lambda_ = 0;
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  lambda_vector_x_ = 0;
  lambda_vector_y_ = 0;
  lambda_vector_z_ = 0;
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  structural_model_x_ = 0;
  structural_model_y_ = 0;
  structural_model_z_ = 0;
#Pendif
  boundary_flux_kmin_ = boundary_flux_kmax_ = 0;
}

void _OP_NAME__ST::initialize(const IJK_Splitting & splitting)
{
  channel_data_.initialize(splitting);
}

void _OP_NAME__ST::calculer(const IJK_Field_ST & field, 
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
                                  const IJK_Field_ST & lambda,
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
                                  const IJK_Field_ST & lambda_vector_x,
                                  const IJK_Field_ST & lambda_vector_y,
                                  const IJK_Field_ST & lambda_vector_z,
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
                                  const IJK_Field_ST & structural_model_x,
                                  const IJK_Field_ST & structural_model_y,
                                  const IJK_Field_ST & structural_model_z,
#Pendif
                                  IJK_Field_ST & result,
                                  const IJK_Field_local_ST & boundary_flux_kmin,
                                  const IJK_Field_local_ST & boundary_flux_kmax)
{
  input_field_ = &field;
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
  lambda_ = &lambda;
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  lambda_vector_x_ = &lambda_vector_x;
  lambda_vector_y_ = &lambda_vector_y;
  lambda_vector_z_ = &lambda_vector_z;
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  structural_model_x_ = &structural_model_x;
  structural_model_y_ = &structural_model_y;
  structural_model_z_ = &structural_model_z;
#Pendif
  boundary_flux_kmin_ = &boundary_flux_kmin;
  boundary_flux_kmax_ = &boundary_flux_kmax;
  compute_set(result);
  input_field_ = 0;
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
  lambda_ = 0;
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  lambda_vector_x_ = 0;
  lambda_vector_y_ = 0;
  lambda_vector_z_ = 0;
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  structural_model_x_ = 0;
  structural_model_y_ = 0;
  structural_model_z_ = 0;
#Pendif
  boundary_flux_kmin_ = boundary_flux_kmax_ = 0;
}

void _OP_NAME__ST::ajouter(const IJK_Field_ST & field, 
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
                                 const IJK_Field_ST & lambda,
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
                                 const IJK_Field_ST & lambda_vector_x,
                                 const IJK_Field_ST & lambda_vector_y,
                                 const IJK_Field_ST & lambda_vector_z,
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
                                 const IJK_Field_ST & structural_model_x,
                                 const IJK_Field_ST & structural_model_y,
                                 const IJK_Field_ST & structural_model_z,
#Pendif
                                 IJK_Field_ST & result,
                                 const IJK_Field_local_ST & boundary_flux_kmin,
                                 const IJK_Field_local_ST & boundary_flux_kmax)
{
  input_field_ = &field;
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
  lambda_ = &lambda;
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  lambda_vector_x_ = &lambda_vector_x;
  lambda_vector_y_ = &lambda_vector_y;
  lambda_vector_z_ = &lambda_vector_z;
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  structural_model_x_ = &structural_model_x;
  structural_model_y_ = &structural_model_y;
  structural_model_z_ = &structural_model_z;
#Pendif
  boundary_flux_kmin_ = &boundary_flux_kmin;
  boundary_flux_kmax_ = &boundary_flux_kmax;
  compute_add(result);
  input_field_ = 0;
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
  lambda_ = 0;
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  lambda_vector_x_ = 0;
  lambda_vector_y_ = 0;
  lambda_vector_z_ = 0;
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  structural_model_x_ = 0;
  structural_model_y_ = 0;
  structural_model_z_ = 0;
#Pendif
  boundary_flux_kmin_ = boundary_flux_kmax_ = 0;
}

#Pforeach DIR(x y z)
void _OP_NAME__ST::compute_flux_DIR(IJK_Field_local_ST & resu, const int k_layer)
{
  ConstIJK_ST_ptr input_field(*input_field_, 0, 0, k_layer);
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic")
  ConstIJK_ST_ptr lambda(*lambda_, 0, 0, k_layer);
#Pendif
#Pif ("CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  ConstIJK_ST_ptr lambda(*lambda_vector_DIR_, 0, 0, k_layer);
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  ConstIJK_ST_ptr structural_model(*structural_model_DIR_, 0, 0, k_layer);
#Pendif
  IJK_ST_ptr resu_ptr(resu, 0, 0, 0);
#Pif ("DIR"=="z")
  // Are we on the wall ?
  const int global_k_layer = k_layer + channel_data_.offset_to_global_k_layer();
  // global index of the layer of flux of the wall
  //  (assume one walls at zmin and zmax)
  const int first_global_k_layer = 0; // index of k_layer when we are on the wall
  // Fluxes in direction k are on the faces, hence, index of last flux is equal to number of elements
  const int last_global_k_layer =  channel_data_.nb_elem_k_tot();

  if (global_k_layer == first_global_k_layer) {
    // We are on wall at kmin, copy boundary condition fluxes to "resu"
    if (boundary_flux_kmin_) // boundary condition is not zero flux
      copy_boundary_condition(*boundary_flux_kmin_, resu);
    else
      putzero(resu);
    return;
  } else if (global_k_layer == last_global_k_layer) {
    if (boundary_flux_kmax_) // boundary condition is not zero flux
      copy_boundary_condition(*boundary_flux_kmax_, resu);
    else
      putzero(resu);
    return;
  }
#Pendif

#Pif ("DIR"=="x")
  const int nx = input_field_->ni() + 1;
  const int ny = input_field_->nj();
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic" or "CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  const ST d0 = channel_data_.get_delta_x() * 0.5;
  const ST d1 = d0;
#Pendif
  const ST surface = channel_data_.get_delta_y() * channel_data_.get_delta_z()[k_layer];
#Pelif ("DIR"=="y")
  const int nx = input_field_->ni();
  const int ny = input_field_->nj() + 1;
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic" or "CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  const ST d0 = channel_data_.get_delta_y() * 0.5;
  const ST d1 = d0;
#Pendif
  const ST surface = channel_data_.get_delta_x() * channel_data_.get_delta_z()[k_layer];
#Pelif ("DIR"=="z")
  const int nx = input_field_->ni();
  const int ny = input_field_->nj();
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic" or "CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  const ST d0 = channel_data_.get_delta_z()[k_layer-1] * 0.5;
  const ST d1 = channel_data_.get_delta_z()[k_layer] * 0.5;
#Pendif
  const ST surface = channel_data_.get_delta_x() * channel_data_.get_delta_y();
#Pendif
#Pmacro KERNEL_FLUX(__TYPE__)
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradVectorial")
  __TYPE__ left_val, right_val, lambda_m1, lambda_m2;
  input_field.get_left_center_DIR(i, left_val, right_val);
  // Fetch conductivity on neighbour cells:
  lambda.get_left_center_DIR(i, lambda_m1, lambda_m2);

  // geometric avg: (d0+d1) / ( d0 / lambda_m1 + d1 / lambda_m2 ), optimized with only 1 division:

  __TYPE__ dsabs = SimdSelect(0, d0 * lambda_m2 + d1 * lambda_m1, d0 * lambda_m2 + d1 * lambda_m1, (-1) * (d0 * lambda_m2 + d1 * lambda_m1));
  __TYPE__ ds = SimdSelect(dsabs, DMINFLOAT, 1., d0 * lambda_m2 + d1 * lambda_m1);
  __TYPE__ avg_lambda = SimdSelect(dsabs, DMINFLOAT, 0., SimdDivideMed(lambda_m1 * lambda_m2, ds));
  // thermal flux is positive if going from left to right => -grad(T)
  __TYPE__ flux = (left_val - right_val) * avg_lambda * surface;
#Pelif ("CASE"=="Yes_M_GradAnisotropic" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  const ST d = d0 + d1;
  __TYPE__ left_val, right_val, lambda_m1, lambda_m2;
  input_field.get_left_center_DIR(i, left_val, right_val);
  // Fetch conductivity on neighbour cells:
  lambda.get_left_center_DIR(i, lambda_m1, lambda_m2);

  // geometric avg: (d0+d1) / ( d0 / lambda_m1 + d1 / lambda_m2 ), optimized with only 1 division:

  __TYPE__ dsabs = SimdSelect(0, d0 * lambda_m2 + d1 * lambda_m1, d0 * lambda_m2 + d1 * lambda_m1, (-1) * (d0 * lambda_m2 + d1 * lambda_m1));
  __TYPE__ ds = SimdSelect(dsabs, DMINFLOAT, 1., d0 * lambda_m2 + d1 * lambda_m1);
  __TYPE__ avg_lambda = SimdSelect(dsabs, DMINFLOAT, 0., SimdDivideMed(d * lambda_m1 * lambda_m2, ds));
  // thermal flux is positive if going from left to right => -grad(T)
  __TYPE__ flux = (left_val - right_val) * avg_lambda * surface;
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  __TYPE__ s_mo, s_mo_dummy;
  structural_model.get_left_center_DIR(i, s_mo_dummy, s_mo);
  __TYPE__ flux = (-1.) * s_mo * surface;
#Pendif
  resu_ptr.put_val(i, flux);
#Pendmacro(KERNEL_FLUX)
#Pmacro KERNEL_FLUX_NEXTJ()
  input_field.next_j();
#Pif ("CASE"=="Yes_M_Grad" or "CASE"=="Yes_M_GradAnisotropic" or "CASE"=="Yes_M_GradVectorial" or "CASE"=="Yes_M_GradVectorialAnisotropic")
  lambda.next_j();
#Pendif
#Pif ("CASE"=="Yes_M_Struct")
  structural_model.next_j();
#Pendif
  resu_ptr.next_j();
#Pendmacro(KERNEL_FLUX_NEXTJ)

#Pusemacro(IJ_LOOP)(ST,nx,ny,KERNEL_FLUX,KERNEL_FLUX_NEXTJ)

}
#Pendforeach(DIR)
#Pendmacro(DEFMACRO)
#Pusemacro(DEFMACRO)(double,Yes_M_Grad,OpDiffIJKScalar)
#Pusemacro(DEFMACRO)(double,Yes_M_GradAnisotropic,OpDiffAnisotropicIJKScalar)
#Pusemacro(DEFMACRO)(double,Yes_M_GradVectorial,OpDiffVectorialIJKScalar)
#Pusemacro(DEFMACRO)(double,Yes_M_GradVectorialAnisotropic,OpDiffVectorialAnisotropicIJKScalar)
#Pusemacro(DEFMACRO)(double,Yes_M_Struct,OpDiffIJKScalarStructuralOnly)
